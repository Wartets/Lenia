#version 450 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D uStateIn;
layout(r32f, binding = 1) writeonly uniform image2D uStateOut;
layout(binding = 2) uniform sampler2D uKernel;
layout(binding = 3) uniform sampler2D uWallTex;
layout(rgba32f, binding = 4) writeonly uniform image2D uNeighborSumsOut;
layout(rgba32f, binding = 5) writeonly uniform image2D uGrowthOut;

layout(std140, binding = 1) uniform SimParams {
    int   uGridW;
    int   uGridH;
    int   uRadius;
    float uDt;
    float uMu;
    float uSigma;
    int   uGrowthType;
    float uParam1;
    float uParam2;
    float uWallValue;
    int   uWallEnabled;
    int   _pad2;
};

float growthLenia(float x, float mu, float sigma) {
    float d = (x - mu) / sigma;
    return 2.0 * exp(-0.5 * d * d) - 1.0;
}

float growthStep(float x, float mu, float sigma) {
    float lo = mu - sigma;
    float hi = mu + sigma;
    return (x >= lo && x <= hi) ? 1.0 : -1.0;
}

float growthPolynomial(float x, float mu, float sigma) {
    float d = (x - mu) / max(sigma, 0.001);
    float v = 1.0 - d * d;
    return v > 0.0 ? v * v - 0.5 : -0.5;
}

float growthExponential(float x, float mu, float sigma) {
    float d = abs(x - mu) / max(sigma, 0.001);
    return 2.0 * exp(-d) - 1.0;
}

float growthDoublePeak(float x, float mu, float sigma) {
    float d1 = (x - mu * 0.7) / max(sigma, 0.001);
    float d2 = (x - mu * 1.3) / max(sigma, 0.001);
    float g1 = exp(-0.5 * d1 * d1);
    float g2 = exp(-0.5 * d2 * d2);
    return 2.0 * max(g1, g2) - 1.0;
}

float growthAsymptoticTarget(float x, float mu, float sigma) {
    float d = (x - mu) / max(sigma, 0.001);
    return exp(-0.5 * d * d);
}

float growthQuad4(float x, float mu, float sigma) {
    float d2 = (x - mu) * (x - mu) / (9.0 * sigma * sigma);
    float v = max(0.0, 1.0 - d2);
    return 2.0 * v * v * v * v - 1.0;
}

float softClip(float x) {
    return 1.0 / (1.0 + exp(-4.0 * (x - 0.5)));
}

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= uGridW || gid.y >= uGridH) return;

    int diameter = (uGrowthType == 2) ? (uRadius * 2 + 1) : (uRadius * 2);
    float potential = 0.0;
    vec2 invGrid = vec2(1.0 / float(uGridW), 1.0 / float(uGridH));
    float invKern = 1.0 / float(diameter);

    for (int ky = 0; ky < diameter; ++ky) {
        float kernRowV = (float(ky) + 0.5) * invKern;
        int oy = ky - uRadius;
        for (int kx = 0; kx < diameter; ++kx) {
            float kernU = (float(kx) + 0.5) * invKern;
            float kw = texture(uKernel, vec2(kernU, kernRowV)).r;
            if (kw < 1e-7) continue;
            int ox = kx - uRadius;
            vec2 sampleUV = (vec2(gid) + vec2(ox, oy) + 0.5) * invGrid;
            potential += texture(uStateIn, sampleUV).r * kw;
        }
    }

    float current = texture(uStateIn, (vec2(gid) + 0.5) * invGrid).r;

    float g;
    if (uGrowthType == 2) {
        float neighbors = potential;
        float alive = current > 0.5 ? 1.0 : 0.0;
        float birth = (alive < 0.5 && neighbors >= 2.5 && neighbors <= 3.5) ? 1.0 : 0.0;
        float survive = (alive > 0.5 && neighbors >= 1.5 && neighbors <= 3.5) ? 1.0 : 0.0;
        float next = max(birth, survive);
        imageStore(uStateOut, gid, vec4(next, 0.0, 0.0, 0.0));
        imageStore(uNeighborSumsOut, gid, vec4(potential, 0.0, 0.0, 0.0));
        imageStore(uGrowthOut, gid, vec4(next - current, 0.0, 0.0, 0.0));
        return;
    } else if (uGrowthType == 3) {
        float bLo = uMu - uSigma * 3.0;
        float bHi = uMu - uSigma;
        float dLo = uMu + uSigma;
        float dHi = uMu + uSigma * 3.0;
        float birth = (potential > bLo && potential < bHi) ? 1.0 : 0.0;
        float death = (potential > dLo && potential < dHi) ? 1.0 : 0.0;
        float newState = current;
        if (current < 0.5 && birth > 0.5) newState = 1.0;
        if (current >= 0.5 && death > 0.5) newState = 0.0;
        float next = clamp((1.0 - uDt) * current + uDt * newState, 0.0, 1.0);
        imageStore(uStateOut, gid, vec4(next, 0.0, 0.0, 0.0));
        imageStore(uNeighborSumsOut, gid, vec4(potential, 0.0, 0.0, 0.0));
        imageStore(uGrowthOut, gid, vec4(next - current, 0.0, 0.0, 0.0));
        return;
    } else if (uGrowthType == 1) {
        g = growthStep(potential, uMu, uSigma);
    } else if (uGrowthType == 4) {
        g = growthPolynomial(potential, uMu, uSigma);
    } else if (uGrowthType == 5) {
        g = growthExponential(potential, uMu, uSigma);
    } else if (uGrowthType == 6) {
        g = growthDoublePeak(potential, uMu, uSigma);
    } else if (uGrowthType == 7) {
        float target = growthAsymptoticTarget(potential, uMu, uSigma);
        float next7 = current + uDt * (target - current);
        imageStore(uStateOut, gid, vec4(clamp(next7, 0.0, 1.0), 0.0, 0.0, 0.0));
        imageStore(uNeighborSumsOut, gid, vec4(potential, 0.0, 0.0, 0.0));
        imageStore(uGrowthOut, gid, vec4(uDt * (target - current), 0.0, 0.0, 0.0));
        return;
    } else if (uGrowthType == 8) {
        g = growthLenia(potential, uMu, uSigma);
        float raw = current + uDt * g;
        float next8 = softClip(raw);
        imageStore(uStateOut, gid, vec4(clamp(next8, 0.0, 1.0), 0.0, 0.0, 0.0));
        imageStore(uNeighborSumsOut, gid, vec4(potential, 0.0, 0.0, 0.0));
        imageStore(uGrowthOut, gid, vec4(uDt * g, 0.0, 0.0, 0.0));
        return;
    } else if (uGrowthType == 9) {
        float b1 = uMu;
        float b2 = uSigma;
        float s1 = uParam1;
        float s2 = uParam2;
        float alive = current > 0.5 ? 1.0 : 0.0;
        float birth = (alive < 0.5 && potential >= b1 && potential <= b2) ? 1.0 : 0.0;
        float survive = (alive > 0.5 && potential >= s1 && potential <= s2) ? 1.0 : 0.0;
        float next9 = max(birth, survive);
        imageStore(uStateOut, gid, vec4(next9, 0.0, 0.0, 0.0));
        imageStore(uNeighborSumsOut, gid, vec4(potential, 0.0, 0.0, 0.0));
        imageStore(uGrowthOut, gid, vec4(next9 - current, 0.0, 0.0, 0.0));
        return;
    } else if (uGrowthType == 10) {
        g = growthQuad4(potential, uMu, uSigma);
    } else {
        g = growthLenia(potential, uMu, uSigma);
    }

    float next = clamp(current + uDt * g, 0.0, 1.0);
    
    // Apply wall constraints
    if (uWallEnabled > 0) {
        vec4 wall = texture(uWallTex, (vec2(gid) + 0.5) * invGrid);
        if (wall.a > 0.01) {
            // Wall is present - force to wall value
            next = uWallValue;
        }
    }
    
    imageStore(uStateOut, gid, vec4(next, 0.0, 0.0, 0.0));
    imageStore(uNeighborSumsOut, gid, vec4(potential, 0.0, 0.0, 0.0));
    imageStore(uGrowthOut, gid, vec4(uDt * g, 0.0, 0.0, 0.0));
}
